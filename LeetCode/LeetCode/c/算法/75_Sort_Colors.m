//
//  75_Sort_Colors.m
//  LeetCode
//
//  Created by 58 on 2020/10/30.
//

#import "75_Sort_Colors.h"

@implementation _5_Sort_Colors

/**
 75. 颜色分类
 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

 注意:
 不能使用代码库中的排序函数来解决这道题。

 示例:

 输入: [2,0,2,1,1,0]
 输出: [0,0,1,1,2,2]
 
 Example 2:

 Input: nums = [2,0,1]
 Output: [0,1,2]
 Example 3:

 Input: nums = [0]
 Output: [0]
 Example 4:

 Input: nums = [1]
 Output: [1]
  

 Constraints:

 n == nums.length
 1 <= n <= 300
 nums[i] is 0, 1, or 2.

 来源：力扣（LeetCode）
 链接：https://leetcode-cn.com/problems/sort-colors
 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 
 进阶：

 一个直观的解决方案是使用计数排序的两趟扫描算法。
 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
 你能想出一个仅使用常数空间的一趟扫描算法吗？
 */

/**
 本题是经典的「荷兰国旗问题」，由计算机科学家 Edsger W. Dijkstra 首先提出。
 根据题目中的提示，我们可以统计出数组中0,1,2的个数，再根据它们的数量，重写整个数组。这种方法较为简单，
 也很容易想到，而本题解中会介绍两种基于指针进行交换的方法。
 
 我们可以考虑对数组进行两次遍历。在第一次遍历中，我们将数组中所有的0 交换到数组的头部。在第二次遍历中，我们将数组中所有的1 交换到头部的0 之后。此时，所有的2 都出现在数组的尾部，这样我们就完成了排序
 
 第一次遍历：
 ptr的位置就是当前0所在的数组索引的后一位，也代表了0的个数
 
 第二次遍历：
 0遍历完成后，ptr的大小就是0的个数，也是1该从index=ptr开始排的索引
 
 */
//方法1
//复杂度分析
//时间复杂度：O(n)，其中n 是数组nums 的长度。
//空间复杂度：(1)。
void swap(int *a, int *b) {
    int t = *a;
    *a = *b;
    *b = t;
}
void sortColors(int *nums, int numsSize) {
    int ptr = 0;
    //ptr的位置就是当前0所在的数组索引的后一位，也代表了0的个数
    for (int i = 0; i < numsSize; ++i) {
        if (nums[i] == 0) {
            swap(&nums[i], &nums[ptr]);//交换
            ++ptr;//记录0所在的index
        }
    }
    //0遍历完成后，ptr的大小就是0的个数，也是1该从index=ptr开始排的索引
    for (int i = ptr; i < numsSize; ++i) {
        if (nums[i] == 1) {
            swap(&nums[i], &nums[ptr]);
            ++ptr;
        }
    }
}

//方法2
//[2,0,2,1,1,0]
/**
 双指针
 两个指针分别指向 下一个0、2应该存放的位置
 遇0则交换 当前元素 和 p0空间的值，并 使得 p0指针 指向 下一个0应该存放的位置，遍历下一个元素
 遇2则交换 当前元素 和 p2空间的值，并 使得 p2指针 指向 下一个2应该存放的位置，继续遍历 交换后的当前元素
 //复杂度分析
 //时间复杂度：O(n)，其中n 是数组nums 的长度。
 //空间复杂度：(1)。
 */
void sortColors2(int *nums, int numsSize){
    int p0 = 0;
    int p2 = numsSize - 1;
    for (int i = p0; i <= p2; i++) {
        if (nums[i] == 0) {//等于0
            //就把p0位置处的未知值换到这个位置
            nums[i] = nums[p0];
            //那么把p0处的值置位0，相当于i和p0进行了交换
            //p0加一,加一后p0处又是个未知值了
            nums[p0++] = 0;
        } else if (nums[i] == 2) {//等于2
            //就把p2的位置处的未知值换到这个位置
            //但是i必须先-1，因为下一轮遍历还得重新在i这个位置开始
            nums[i--] = nums[p2];
            //那么把p2处的值置位2，相当于i和p2进行了交换
            //p2减一,减一后p2处又是个未知值了
            nums[p2--] = 2;
        }
    }
}
@end
