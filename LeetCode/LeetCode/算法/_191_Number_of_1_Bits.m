//
//  _191_Number_of_1_Bits.m
//  LeetCode
//
//  Created by 58 on 2020/12/28.
//

#import "_191_Number_of_1_Bits.h"

@implementation _191_Number_of_1_Bits


/**
 191. 位1的个数
 难度 简单
 https://leetcode-cn.com/problems/number-of-1-bits/
 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。
 进阶：
 如果多次调用这个函数，你将如何优化你的算法？
 示例 1：

 输入：00000000000000000000000000001011
 输出：3
 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
 示例 2：

 输入：00000000000000000000000010000000
 输出：1
 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
 示例 3：

 输入：11111111111111111111111111111101
 输出：31
 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
 提示：

 输入必须是长度为 32 的 二进制串 。
 */

/**
 位操作：
 异或^: 如果a、b两个二进制位数字不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。
 
 1 利用或操作 | 和空格将英文字符转换为小写
 ('a' | ' ') = 'a'
 ('A' | ' ') = 'a'
 
 2 利用与操作 & 和下划线将英文字符转换为大写
 ('b' & '_') = 'B'
 ('B' & '_') = 'B'
 
 3 利用异或操作 ^ 和空格进行英文字符大小写互换
 ('d' ^ ' ') = 'D'
 ('D' ^ ' ') = 'd'
 
 以上操作能够产生奇特效果的原因在于 ASCII 编码。字符其实就是数字，恰巧这些字符对应的数字通过位运算就能得到正确的结果。
 
 4 判断两个数是否异号
 int x = -1, y = 2;
 bool f = ((x ^ y) < 0); // true

 int x = 3, y = 2;
 bool f = ((x ^ y) < 0); // false
 
 这个技巧还是很实用的，利用的是补码编码的符号位。如果不用位运算来判断是否异号，需要使用 if else 分支，还挺麻烦的。如果利用乘积或者商来判断两个数是否异号，但是这种处理方式可能造成溢出，从而出现错误。
 
 5 不用临时变量交换两个数
 int a = 1, b = 2;
 a ^= b;
 b ^= a;
 a ^= b;
 // 现在 a = 2, b = 1

 6 加一
 int n = 1;
 n = -~n;
 // 现在 n = 2
 
 7 减一
 int n = 2;
 n = ~-n;
 // 现在 n = 1
 
 8 一个数和它本身做异或运算结果为 0
 a ^ a = 0;
 
 9 一个数和 0 做异或运算的结果为它本身
 a ^ 0 = a;
 
 */





/**
 位移动
 我们使用 位掩码 来检查数字的第i位。一开始，掩码m=1 因为 1 的二进制表示是 0000 0000 0000 0000 0000 0000 0000 0001
 显然，任何数字跟掩码 1 进行逻辑与运算，都可以让我们获得这个数字的最低位。检查下一位时，我们将掩码左移一位。
 
 时间复杂度：O(1) 。运行时间依赖于数字 n 的位数。由于这题中 n 是一个 32 位数，所以运行时间是 O(1) 的。
 空间复杂度：O(1)。没有使用额外空间。
 */
int hammingWeight(uint32_t n) {
    int bits = 0;
    uint mask = 1;
    for (int i = 0; i < 32; i++) {
        if ((n & mask) != 0) {
            bits++;
        }
        mask <<= 1; //1 10 100.... 就这样左移一位和n进行与运算
    }
    return bits;
}

/**
 优化
 n&(n-1) 这个操作是算法中常见的，作用是消除数字 n 的二进制表示中的最后一个 1。
 比如 n = 110100，则 n-1 = 110011
 那么：
  110100
 &110011
 --------
  110000
 得到110000和110100相比就是去掉了一个1，然后res累加计数即可
 
 */
int hammingWeight2(uint32_t n) {
    int res = 0;
    while (n != 0) {
        n = n & (n - 1);
        res++;
    }
    return res;
}
/**
 引申
 判断一个数是不是 2 的指数
 一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1：
 2^0 = 1 = 0b0001
 2^1 = 2 = 0b0010
 2^2 = 4 = 0b0100
 如果使用 n&(n-1) 的技巧就很简单了（注意运算符优先级，括号不可以省略）：
 */
bool isPowerOfTwo(int n) {
    if (n <= 0) return false;
    return (n & (n - 1)) == 0;
}

/**
 136. 只出现一次的数字
 难度 简单
 https://leetcode-cn.com/problems/single-number/
 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
 说明：
 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
 示例 1:
 输入: [2,2,1]
 输出: 1
 示例 2:
 输入: [4,1,2,1,2]
 输出: 4
 */
int singleNumber(int* nums, int numsSize){
    int res = 0;
    for (int i=0; i<numsSize; i++) {
        int n = nums[i];
        res ^= n;
        printf("%d\n",res);
    }
    return res;
}
void singleNumberTest(void){
    int a[]={4,1,2,1,2};
    singleNumber(a, 5);
}

@end
