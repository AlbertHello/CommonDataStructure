//
//  chiputao.m
//  LeetCode
//
//  Created by Albert on 2021/1/3.
//

#import "chiputao.h"
#include "QuickSort.h"



@implementation chiputao

/**
 牛客网： 吃葡萄
 有三种葡萄，每种分别有 a, b, c 颗，现在有三个人，第一个人只吃第一种和第二种葡萄，第二个人只吃第二种和第三种葡萄，第三个人只吃第一种和第三种葡萄。
 现在给你输入 a, b, c 三个值，请你适当安排，让三个人吃完所有的葡萄，算法返回吃的最多的人最少要吃多少颗葡萄。
 
 https://www.nowcoder.com/questionTerminal/14c0359fb77a48319f0122ec175c9ada
 */

/**
 可以这样理解，我们先不管每个人只能吃两种特定葡萄的约束，你怎么让「吃得最多的那个人吃得最少」？
 显然，只要平均分就行了，每个人吃 (a+b+c)/3 颗葡萄。即便不能整除，比如说 a+b+c=8，那也要尽可能平均分，就是说一个人吃 2 颗，另两个人吃 3 颗。
 综上，「吃得最多的那个人吃得最少」就是让我们尽可能地平均分配，而吃的最多的那个人吃掉的葡萄颗数就是 (a+b+c)/3 向上取整的结果，也就是 (a+b+c+2)/3。
 PS：向上取整是一个常用的算法技巧。大部分编程语言中，如果你想计算 M 除以 N，M / N 会向下取整，你想向上取整的话，可以改成 (M+(N-1)) / N。
 现在考虑一下如果加上「每个人只能吃特定两种葡萄」的限制，怎么做？
 如果把葡萄的颗数 a, b, c 作为三条线段，它们的大小作为线段的长度，想一想它们可能组成什么几何图形？我们的目的是否可以转化成「尽可能平分这个几何图形的周长」？
 
 如果 a + b > c，那么可以构成一个三角形，平分周长，那么依然是(a+b+c+2)/3。
 如果 a + b <= c，那么这三条边就不能组成一个封闭的图形了，那么我们可以将最长边 c「折断」，也就是形成一个四边形。
 这里面有两种情况：
 情况一，a + b 和 c 的差距还不大的时候，可以看到依然能够让三个人平分这个四边形，
 那么吃的最多的人最少可以吃到的葡萄颗数依然是 (a+b+c+2)/3。
 随着 c 的不断增大，就会出现情况二，此时 c > 2*(a+b)，由于每个人口味的限制，为了尽可能平分，X 最多吃完 a 和 b，而 c 边需要被 Y 或 Z 平分，也就是说此时吃的最多的人最少可以吃到的葡萄颗数就是 (c+1)/2，即平分 c 边向上取整。
 
 */
long solution(long a, long b, long c) {
    long nums[3] = {a, b, c};
    quick_sort(nums, 0, 3);
    long sum = a + b + c;
    // 能够构成三角形，可完全平分
    if (nums[0] + nums[1] > nums[2]) {
        return (sum + 2) / 3;
    }
    // 不能构成三角形，平分最长边的情况。 情况2
    if (2 * (nums[0] + nums[1]) < nums[2]) {
        return (nums[2] + 1) / 2;
    }
    // 不能构成三角形，但依然可以完全平分的情况. 情况1
    return (sum + 2) / 3;
}
@end
